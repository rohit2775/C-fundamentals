 ## types of inheritance 

  1. single inheritance
  2. multilevel inheritance
  3. multiple inheritance 
  4. hierarchical inheritance
  5.hybrid inheritance 


############ Single Inheritance

Single inheritance means when one child class (derived class) inherits from only one parent class (base class).
It allows the child class to reuse the properties and methods of the parent class without rewriting them.

👉 Example idea:

Vehicle is the parent class (it has general properties like wheels, engine).
Car is the child class that inherits from Vehicle and adds its own features (like air conditioning).

🔹 Code Example (C++)
#include <iostream>
using namespace std;

// Base class (Parent)
class Vehicle {
public:
    void start() {
        cout << "Vehicle is starting..." << endl;
    }
};

// Derived class (Child)
class Car : public Vehicle {
public:
    void feature() {
        cout << "Car has Air Conditioning." << endl;
    }
};

int main() {
    Car myCar;

    // Inherited function from Vehicle
    myCar.start();

    // Function from Car class
    myCar.feature();

    return 0;
}

🔹 Output:
Vehicle is starting...
Car has Air Conditioning.

🔹 Real-world analogy:

It’s like a son inheriting his father’s property and also adding his own things.
That’s single inheritance → inheriting from only one parent.




one more example for better understanding 


#include <iostream>
using namespace std;

// Base class
class Student {
public:
    string name;
    int roll;

    void getInfo(string n, int r) {
        name = n;
        roll = r;
    }

    void displayInfo() {
        cout << "Name: " << name << endl;
        cout << "Roll: " << roll << endl;
    }
};

// Derived class
class Marks : public Student {
public:
    int score;

    void setScore(int s) {
        score = s;
    }

    void displayScore() {
        cout << "Score: " << score << endl;
    }
};

int main() {
    Marks m1;

    // Using base class function
    m1.getInfo("Rohit", 101);
    m1.displayInfo();

    // Using derived class function
    m1.setScore(95);
    m1.displayScore();

    return 0;
}


here 

Student = parent class (common info like name, roll).
Marks = child class (extra info like score).
Marks inherits everything from Student, so it can use both parent functions and its own functions.


lets get some more examples for better understansings 

example 1 ::

#include <iostream>
using namespace std;

class Student {
public:
    void showStudent() {
        cout << "This is a student" << endl;
    }
};

class Result : public Student {
public:
    void showResult() {
        cout << "Student got 90 marks" << endl;
    }
};

int main() {
    Result r;
    r.showStudent();
    r.showResult();
    return 0;
}



example 2 ::

#include <iostream>
using namespace std;

class Person {
public:
    void displayPerson() {
        cout << "I am a person" << endl;
    }
};

class Employee : public Person {
public:
    void displayEmployee() {
        cout << "I am an employee" << endl;
    }
};

int main() {
    Employee e;
    e.displayPerson();   // from parent
    e.displayEmployee(); // from child
    return 0;
}


example 3 ::


#include <iostream>
using namespace std;

class Vehicle {
public:
    void start() {
        cout << "Vehicle is starting..." << endl;
    }
};

class Car : public Vehicle {
public:
    void showCar() {
        cout << "This is a car" << endl;
    }
};

int main() {
    Car c;
    c.start();    // parent class function
    c.showCar();  // child class function
    return 0;
}\

last example ::::;

#include <iostream>
using namespace std;

// Parent Class (Base)
class BankAccount {
public:
    string accountHolder;
    int accountNumber;
    double balance;

    // Function to set details
    void setDetails(string name, int accNo, double bal) {
        accountHolder = name;
        accountNumber = accNo;
        balance = bal;
    }

    // Show details
    void showDetails() {
        cout << "Account Holder: " << accountHolder << endl;
        cout << "Account Number: " << accountNumber << endl;
        cout << "Balance: $" << balance << endl;
    }
};

// Child Class (Derived)
class SavingsAccount : public BankAccount {
public:
    double interestRate;

    void setInterestRate(double rate) {
        interestRate = rate;
    }

    void calculateInterest() {
        double interest = (balance * interestRate) / 100;
        cout << "Interest Earned: $" << interest << endl;
    }
};

int main() {
    SavingsAccount s1;

    // Parent class function
    s1.setDetails("Rohit", 10101, 5000);

    // Child class function
    s1.setInterestRate(5.0);

    // Show results
    s1.showDetails();
    s1.calculateInterest();

    return 0;
}


the output will be ..
Account Holder: Rohit
Account Number: 10101
Balance: $5000
Interest Earned: $250

  

######## multiple levwl inheritance 

 in this type there are multiple levels of single inheritance .. ..

   let us see a axample for better uderstanding 

   class A{

   };

   class B :public A{

   }:
   
   class C:public B{

   };


   ... here we have to aware about the parent class and the child class of particular classes 
    like parent class of C is B 
    and parent class of B is A;



######### multiple inheritance .....

       if a class have more than one parent class then it is said to be multiple inheritance ..

       like ...

       class a{

       };

       class b{

       };

       class c:public a,public b {
  
       };

       here class c inherits class a and b means  class  c have two parents i.e. class a and class b 




some example codes are .....

        #include <iostream>
using namespace std;

class A {
public:
    void showA() { cout << "This is class A" << endl; }
};

class B {
public:
    void showB() { cout << "This is class B" << endl; }
};

// Class C inherits from A and B
class C : public A, public B {
public:
    void showC() { cout << "This is class C" << endl; }
};

int main() {
    C obj;
    obj.showA();
    obj.showB();
    obj.showC();
    return 0;
}

example 2 

#include <iostream>
using namespace std;

class Engine {
public:
    void engineType() { cout << "Petrol Engine" << endl; }
};

class Wheels {
public:
    void wheelType() { cout << "Alloy Wheels" << endl; }
};

// Car has both Engine and Wheels
class Car : public Engine, public Wheels {
public:
    void display() { cout << "This is a Car" << endl; }
};

int main() {
    Car myCar;
    myCar.engineType();
    myCar.wheelType();
    myCar.display();
    return 0;
}



### hierarchical inheritance 

when  different classes are formed by inheriting the same parent class , called hierearchical inheritance 

like ::
    
    class A{

    };
    class B :public A{

    };
    class C:public A{

    };
    

    here the parent class of B and C is A


    lets get some example code 
    example1 ::


     
    #include <iostream>
using namespace std;

class Animal {
public:
    void eat() { cout << "Animals can eat" << endl; }
};

class Dog : public Animal {
public:
    void bark() { cout << "Dog barks" << endl; }
};

class Cat : public Animal {
public:
    void meow() { cout << "Cat meows" << endl; }
};

int main() {
    Dog d;
    d.eat();
    d.bark();

    Cat c;
    c.eat();
    c.meow();

    return 0;
}
 

 example 2 :

   #include <iostream>
using namespace std;

class Shape {
public:
    void area() { cout << "Every shape has an area" << endl; }
};

class Circle : public Shape {
public:
    void drawCircle() { cout << "Drawing Circle" << endl; }
};

class Square : public Shape {
public:
    void drawSquare() { cout << "Drawing Square" << endl; }
};

int main() {
    Circle c;
    c.area();
    c.drawCircle();

    Square s;
    s.area();
    s.drawSquare();
    return 0;
}









###### hybrid inheritance ...

hybrid inheritance means combination of two or more types of inheritance in a single program .. 
we mix different nheritance types like single , multiple ,  multilevel , hierearchical together in a program is called 
hybrid inheritane ...


example code 

#include <iostream>
using namespace std;

class A {
public:
    void showA() { cout << "This is A" << endl; }
};

class B : public A {
public:
    void showB() { cout << "This is B" << endl; }
};

class C {
public:
    void showC() { cout << "This is C" << endl; }
};

// D inherits from both B (which already has A) and C
class D : public B, public C {
public:
    void showD() { cout << "This is D" << endl; }
};

int main() {
    D obj;
    obj.showA();
    obj.showB();
    obj.showC();
    obj.showD();
    return 0;
}

#include <iostream>
using namespace std;

// Base class
class Student {
public:
    void details() { cout << "Student Details" << endl; }
};

// Derived class from Student
class Marks : public Student {
public:
    void getMarks() { cout << "Student Marks" << endl; }
};

// Another base class
class Sports {
public:
    void getSportsScore() { cout << "Student Sports Score" << endl; }
};

// Result inherits from both Marks (which already inherits Student) and Sports
class Result : public Marks, public Sports {
public:
    void displayResult() { cout << "Final Result of Student" << endl; }
};

int main() {
    Result r;
    r.details();
    r.getMarks();
    r.getSportsScore();
    r.displayResult();
    return 0;
}


visibility modes in C++
  -private
  -protected 
  -public 



When a class inherits another class, the visibility mode decides how the base class members are accessible in the derived class.

1. Public inheritance

class Derived : public Base { ... };

Public members of Base → stay Public in Derived.
Protected members of Base → stay Protected in Derived.
Private members of Base → ❌ not accessible.
👉 Use when: You want a real is-a relationship.
Example: Dog is an Animal, SportsCar is a Car.

2. Protected Inheritance

class Derived : protected Base { ... };

Public members of Base → become Protected in Derived.
Protected members of Base → stay Protected in Derived.
Private members of Base → ❌ not accessible.
👉 Use when: You want inheritance, but you don’t want to expose base class members to the outside world.
Example: Internal implementations where only derived classes should use them.

3. Private inheritance 

class Derived : private Base { ... };
Public members of Base → become Private in Derived.
Protected members of Base → become Private in Derived.
Private members of Base → ❌ not accessible.
👉 Use when: You only want to use the base class internally, but don’t want the derived class to be seen as a type of the base class.
Example: Car uses Engine internally → not “Car is an Engine”.


✅ So in short:

Public inheritance → Use for “is-a” relationships.

Protected inheritance → Use when only derived classes should access base members.

Private inheritance → Use when base is just an internal helper, not a parent type.





note : use inheritance with the usecase ... 



here are some usecases for  inheritance 

1. Vehicle Hierarchy

Use case: You have a base Vehicle class and specific vehicles like Car, Bike, Truck.

Reason: All vehicles share common properties like speed, fuelType, and methods like start(), stop().

Example:

class Vehicle:
    def start(self):
        print("Vehicle started")

class Car(Vehicle):
    def open_trunk(self):
        print("Trunk opened")

class Bike(Vehicle):
    def kick_start(self):
        print("Bike kick-started")


✅ Good because Car is a Vehicle.

2. Employee Management System

Use case: Base class Employee with subclasses Manager, Developer, Intern.

Reason: All employees have name, salary, work() methods. But each subclass can have specialized behavior.

Example:

class Employee:
    def __init__(self, name):
        self.name = name

    def work(self):
        print(f"{self.name} is working")

class Manager(Employee):
    def manage(self):
        print(f"{self.name} is managing the team")

class Developer(Employee):
    def code(self):
        print(f"{self.name} is writing code")

3. Shape Drawing (Graphics)

Use case: Base class Shape with Circle, Rectangle, Triangle.

Reason: All shapes can draw() and area(), but implementations differ.

class Shape:
    def draw(self):
        pass

class Circle(Shape):
    def draw(self):
        print("Drawing a circle")

class Rectangle(Shape):
    def draw(self):
        print("Drawing a rectangle")

4. Animal Classification

Use case: Base class Animal with Dog, Cat, Bird.

Reason: All animals have common behavior (eat(), sleep()) but some have specific behaviors (bark(), fly()).

class Animal:
    def eat(self):
        print("Eating")

class Dog(Animal):
    def bark(self):
        print("Barking")

class Bird(Animal):
    def fly(self):
        print("Flying")

5. GUI Widgets

Use case: Base class Widget with Button, Textbox, Checkbox.

Reason: All widgets have render() and click() methods but each is different.

class Widget:
    def render(self):
        print("Rendering widget")

class Button(Widget):
    def click(self):
        print("Button clicked")

class Textbox(Widget):
    def type_text(self, text):
        print(f"Typing {text}")